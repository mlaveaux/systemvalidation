


sort Resource = struct Water|Milk|Sugar|Cup|CoffeeBean;
sort Product = struct p_Coffee|p_HotWater|p_ColdWater|p_Milk|p_Sugar;
sort Value = struct tencent|fivecent|twentycent|fiftycent|oneeuro|twoeuro; 
sort ResourceSet = Set (Resource);
sort ProductSet = Set (Product);
sort PProductSet = Set (ProductSet);
map allowedProductSet: ProductSet -> Bool;
var ps : ProductSet;
eqn (ps == {p_ColdWater} || ps == {p_HotWater} || ps == {p_Coffee} || ps == {p_Coffee,p_Milk} || ps == {p_Coffee,p_Sugar} || ps == {p_Coffee,p_Sugar,p_Milk}) -> allowedProductSet(ps) = true;
	(ps != {p_ColdWater} && ps != {p_HotWater} && ps == {p_Coffee} && ps == {p_Coffee,p_Milk} && ps == {p_Coffee,p_Sugar} && ps == {p_Coffee,p_Sugar,p_Milk}) -> allowedProductSet(ps) = false;
	

map needed_for: Resource # Product -> Bool;
eqn 
	needed_for(Water, p_Coffee) = true;
	needed_for(Water, p_HotWater) = true;
	needed_for(Water, p_ColdWater) = true;
	needed_for(Water, p_Milk) = false;
	needed_for(Water, p_Sugar) = false;
	needed_for(Milk, p_Coffee) = false;
	needed_for(Milk, p_HotWater) = false;
	needed_for(Milk, p_ColdWater) = false;
	needed_for(Milk, p_Milk) = true;
	needed_for(Milk, p_Sugar) = false;
	needed_for(Sugar, p_Coffee) = false;
	needed_for(Sugar, p_HotWater) = false;
	needed_for(Sugar, p_ColdWater) = false;
	needed_for(Sugar, p_Milk) = false;
	needed_for(Sugar, p_Sugar) = true;
	needed_for(Cup, p_Coffee) = true;
	needed_for(Cup, p_HotWater) = true;
	needed_for(Cup, p_ColdWater) = true;
	needed_for(Cup, p_Milk) = false;
	needed_for(Cup, p_Sugar) = false;
	needed_for(CoffeeBean, p_Coffee) = true;
	needed_for(CoffeeBean, p_HotWater) = false;
	needed_for(CoffeeBean, p_ColdWater) = false;
	needed_for(CoffeeBean, p_Milk) = false;
	needed_for(CoffeeBean, p_Sugar) = false;

map value : Value -> Pos;
var v : Value;
eqn (v==tencent) -> value(v) = 10;
    (v==fivecent) -> value(v) = 5;
    (v==twentycent) -> value(v) = 20;
    (v==fiftycent) -> value(v) = 50;
    (v==oneeuro) -> value(v) = 100;
    (v==twoeuro) -> value(v) = 200;

act
	% Controller to machine.
	heat_water;
	return_last_coin;
	return_money;
	deposit_money;
	place_cup;
	collect : Resource;
	pour;
  
	% Machine to controller.
	water_heated;
	cup_placed : Bool;
	pour_done;
	coin : Value;
	empty : Resource;

    % Controller to user interface.
    show_money : Nat;	
    set_selectable : Product # Bool;
    set_empty : Resource # Bool;

    % User interface to controller.
    pressed : Product;
    cancel;

	% Other
	available : Resource;
	too_much_coin : Value;
	products_selected : ProductSet;
	get_selected_products : ProductSet;
	comm_product : ProductSet;
	pour_ready;
	select_ready;
	ready;
	
proc
%%%%%%%%%%%%%%%%%%%%%%%Water%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	PlaceCup = cup_placed(false).place_cup.PlaceCup + cup_placed(true);
	
	HeatWater = heat_water.water_heated;
	
	Pour = (pour_ready + (sum products:ProductSet.(allowedProductSet(products)) -> get_selected_products(products). ((p_ColdWater in products) -> PlaceCup <> HeatWater.PlaceCup) . Collect(products,{}).pour.pour_done )). Pour;
	
	Collect(products: ProductSet, resources : ResourceSet) = sum p:Product .sum r:Resource.(p in products && needed_for(r,p) && !( r in resources) && r != Water && r != Cup) -> collect(r).Collect(products, {res:Resource|res in resources || res == r }) ;

%%%%%%%%%%%%%%%%%%%%%%empty%%%%%%%%%%%%%%%%%%%%%%%%%%%
	IsAvailableSet(s: ResourceSet) = sum r:Resource. ((Available(s).IsAvailableSet(s)) + ((r in s ) -> empty(r).set_empty(r,true).IsAvailableSet({R: Resource| R in s && R != r}))); 

    Available(s: ResourceSet) = sum r:Resource. (r in s) -> available(r);

    StartEmpty = IsAvailableSet({R:Resource|true});
	
%%%%%%%%%%%%%%%%%%%%selection%%%%%%%%%%%%%%%%%%%%%%%%

    Reset = select_ready.set_selectable(p_Milk, false).set_selectable(p_Sugar, false)
        .(set_selectable(p_Coffee, true)+tau).(set_selectable(p_HotWater, true)+tau)
        .(set_selectable(p_ColdWater, true)+tau);

    ProductSelect = 
		% when coffee is selected
		pressed(p_Coffee)
		% set milk sugar selectable and the rest unselectable
		.((set_selectable(p_Milk, true)+tau).(set_selectable(p_Sugar, true)+tau).set_selectable(p_Coffee, false).set_selectable(p_HotWater, false).set_selectable(p_ColdWater, false)
		% and when milk and or sugar is selected
		.(pressed(p_Milk).CountMoney(0, {p : Product|p==p_Coffee || p==p_Milk}) + pressed(p_Sugar).CountMoney(0, {p : Product|p==p_Coffee || p==p_Sugar}) + (pressed(p_Milk).pressed(p_Sugar) + pressed(p_Sugar).pressed(p_Milk)).CountMoney(0, {p : Product|p==p_Coffee || p==p_Milk || p==p_Sugar}) + CountMoney(0, {p : Product|p==p_Coffee})))
		% or when hot water or cold water is selected
		+ pressed(p_HotWater).products_selected({p : Product|p==p_HotWater}).StartSelection + pressed(p_ColdWater).products_selected({p : Product|p==p_ColdWater}).StartSelection;

    CountMoney(total : Nat, products : ProductSet) = 
		sum v:Value.
			(total < 100 && value(v)+total <= 100) -> (coin(v).CountMoney(total + value(v), products) + cancel.UIComponent) <> 
			(total < 100 && value(v)+total > 100) -> (too_much_coin(v).return_last_coin.CountMoney(total, products))<>
			products_selected(products).StartSelection;

    UIComponent = Reset.ProductSelect;

    StartSelection = UIComponent;


	
init
block({products_selected,get_selected_products,pour_ready,select_ready},
  comm({products_selected|get_selected_products -> comm_product,pour_ready|select_ready -> ready},hide({coin},StartSelection) || Pour)); 
  %|| StartEmpty;